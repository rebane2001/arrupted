<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>touch the bytes</title>
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      border: 0;
      overflow: hidden;
    }
    canvas {
      image-rendering: pixelated;
      position: absolute;
    }
    #bgCanvas {
      filter: blur(24px);
    }
    #mainCanvas {
      z-index: 1;
    }
  </style>
</head>
<body>
<canvas id="bgCanvas"></canvas>
<canvas id="mainCanvas"></canvas>
<script>
  let volume = 0.35;
  const audioContext = new AudioContext();
  function beep(t, f, l, v) {
    const vol = audioContext.createGain();
    const oscillator = audioContext.createOscillator();
    oscillator.type = t;
    oscillator.frequency.value = f;
    oscillator.connect(vol);
    vol.connect(audioContext.destination);
    vol.gain.value = v*volume;
    oscillator.start();
    setTimeout(() => oscillator.stop(), l);
  }

  const mainCanvas = document.getElementById("mainCanvas");
  const bgCanvas = document.getElementById("bgCanvas");
  let ctx = mainCanvas.getContext("2d");
  let btx = bgCanvas.getContext("2d");
  let currentFile = null;
  let currentImage = null;
  let currentCorruptedFile = null;
  let currentCorruptedImage = null;
  let lastWasError = false;

  function resizeCanvas() {
    ctx.canvas.width  = window.innerWidth;
    ctx.canvas.height = window.innerHeight;
    btx.canvas.width  = window.innerWidth;
    btx.canvas.height = window.innerHeight;
  }

  let lastMouseX = 0;
  let lastMouseY = 0;
  function handleMouseMove(e) {
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    corrupt();
  }

  function arr2img(arr) {
    return window.URL.createObjectURL(new Blob([arr], { type: 'image/jpeg' }));
  }

  async function loadImage() {
    const resp = await fetch("image.jpg");
    const cont = await resp.blob();
    const buff = await cont.arrayBuffer();
    currentFile = new Uint8Array(buff);
    currentImage = new Image();
    currentImage.src = arr2img(currentFile);
  }

  function handleMouseClick() {
    if (lastWasError) return;
    if (!currentCorruptedFile) return;
    currentFile = currentCorruptedFile;
    currentImage = currentCorruptedImage;
  }



  function corrupt() {
    if (!currentFile) return;
    const touchArea = getTouchArea();
    const dataCount = currentFile.length;
    const pixelCount = touchArea[2]*touchArea[3];
    const mouseInnerX = lastMouseX - touchArea[0];
    const mouseInnerY = lastMouseY - touchArea[1];
    const yReduce = Math.floor(Math.sqrt(pixelCount/dataCount)) || 1;
    let mouseDataIndex = -1;
    if (mouseInnerX >= 0 && mouseInnerY >= 0 && mouseInnerX < touchArea[2] && mouseInnerY < touchArea[3]) {
     mouseDataIndex = Math.floor((mouseInnerX + Math.floor(mouseInnerY/yReduce)*touchArea[2])*(dataCount/pixelCount)*yReduce);
    }
    if (mouseDataIndex === -1) {
      currentCorruptedImage = currentImage;
      currentCorruptedFile = currentFile;
      return;
    }

    const corruptedTemp = new Uint8Array(new ArrayBuffer(currentFile.byteLength));
    corruptedTemp.set(new Uint8Array(currentFile));
    // beep("square", 1000 + corruptedTemp[mouseDataIndex]*4, 1, 0.1);
    corruptedTemp[mouseDataIndex] = Math.floor(Math.random()*256);



    const tempCorruptedImage = new Image();
    tempCorruptedImage.onerror = () => lastWasError = true;
    tempCorruptedImage.onload = () => {
      lastWasError = false;
      currentCorruptedImage = tempCorruptedImage;
      currentCorruptedFile = corruptedTemp;
      // currentCorruptedImage.onload = () => render(-1);
    };
    tempCorruptedImage.src = arr2img(corruptedTemp);
  }

  function getTouchArea() {
    //return [ctx.canvas.width - 384, ctx.canvas.height - 256, 384, 256];
    return getLayout().glitchbox;
  }

  function getLayout() {
    const p = 24; // padding
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    const menubar = [p, p, w-p*2, 64];
    const sidebar = [w-256-p, p*2+menubar[3], 256, h-p*3-menubar[3]];
    const mainHeight = h - menubar[3] - p*3;
    const mainWidth = w - sidebar[2] - p*3;
    const maxImgWidth = Math.floor((mainWidth-p)*0.75);
    let imageRatio = 1;
    if (currentImage) {
      imageRatio = currentImage.naturalWidth/currentImage.naturalHeight || 1;
    }
    const imagebox = [p, 2*p+menubar[3], Math.floor(imageRatio*mainHeight), mainHeight];
    if (imagebox[2] > maxImgWidth) {
      imagebox[2] = maxImgWidth;
      imagebox[3] = Math.floor(maxImgWidth/imageRatio);
      imagebox[1] += Math.floor((mainHeight - imagebox[3])/2);
    }
    const glitchbox = [p*2 + imagebox[2], 2*p+menubar[3], Math.max(1, mainWidth - imagebox[2] - p), Math.max(1, mainHeight)];
    return {
      menubar,
      sidebar,
      imagebox,
      glitchbox,
    };
  }

  function render(delta) {
    const layout = getLayout();

    ctx.fillStyle = "white";
    ctx.fillStyle = "#FFF1";
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    if (currentCorruptedImage) {
      //ctx.drawImage(currentCorruptedImage, 0, 0);
      //ctx.drawImage(currentCorruptedImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
      btx.globalAlpha = 0.02;
      btx.drawImage(currentCorruptedImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.drawImage(currentCorruptedImage, ...layout.imagebox);
    } else if (currentImage) {
      ctx.drawImage(currentImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
    }
    if (currentFile) {
      const touchArea = getTouchArea();
      const dataCount = currentFile.length;
      const pixelCount = touchArea[2]*touchArea[3];
      const yReduce = Math.floor(Math.sqrt(pixelCount/dataCount)) || 1;
      //ctx.fillStyle = "#000";
      //ctx.fillRect(...touchArea);
      const myImageData = ctx.createImageData(touchArea[2], touchArea[3]);

      const mouseInnerX = lastMouseX - touchArea[0];
      const mouseInnerY = lastMouseY - touchArea[1];
      let mouseDataIndex = -1;
      if (mouseInnerX < touchArea[2] && mouseInnerY < touchArea[3]) {
        mouseDataIndex = Math.floor((mouseInnerX + Math.floor(mouseInnerY/yReduce)*touchArea[2])*(dataCount/pixelCount)*yReduce);
      }

      const data = myImageData.data;
      for (let i = 0; i < pixelCount/yReduce; i++) {
        for (let yr = 0; yr < yReduce; yr++) {
          const pix = ((Math.floor(i/touchArea[2])*yReduce+yr)*touchArea[2] + (i%touchArea[2]))*4;
          for (let j = 0; j < 3; j++) {
            const dataIndex = Math.floor((i*yReduce*3+j)*(dataCount/pixelCount/3));
            data[pix+j] = currentFile[dataIndex];
            if (mouseDataIndex == Math.floor((i*yReduce)*(dataCount/pixelCount))) {
              data[pix] = 255;
              data[pix+1] = 0;
            }
          }
          data[pix+3] = 255;
        }
        
      }
      ctx.putImageData(myImageData, touchArea[0], touchArea[1]);
    }

    if (lastWasError) {
      ctx.fillStyle = "red";
      ctx.fillRect(8,8,16,16);
    }

    ctx.beginPath();
    ctx.rect(...layout.menubar);
    ctx.rect(...layout.sidebar);
    ctx.fillStyle = "#564D80";
    ctx.strokeStyle = "#44344F";
    ctx.fill();
    ctx.stroke();

    if (delta !== -1)
      requestAnimationFrame(render);
  }

  window.onload = () => {
    window.addEventListener('resize', resizeCanvas, false);
    window.addEventListener('mousemove', handleMouseMove, false);
    window.addEventListener('click', handleMouseClick, false);
    window.addEventListener('wheel', corrupt, false);
    resizeCanvas();
    requestAnimationFrame(render);
    loadImage();
  };
</script>
</body>
</html>
