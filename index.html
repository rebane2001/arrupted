<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>touch the bytes</title>
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      border: 0;
      overflow: hidden;
    }
    canvas {
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
<canvas id="mainCanvas"></canvas>
<script>
  let volume = 0.35;
  const audioContext = new AudioContext();
  function beep(t, f, l, v) {
    const vol = audioContext.createGain();
    const oscillator = audioContext.createOscillator();
    oscillator.type = t;
    oscillator.frequency.value = f;
    oscillator.connect(vol);
    vol.connect(audioContext.destination);
    vol.gain.value = v*volume;
    oscillator.start();
    setTimeout(() => oscillator.stop(), l);
  }

  const mainCanvas = document.getElementById("mainCanvas");
  let ctx = mainCanvas.getContext("2d");
  let currentFile = null;
  let currentImage = null;
  let currentCorruptedFile = null;
  let currentCorruptedImage = null;
  let lastWasError = false;

  function resizeCanvas() {
    ctx.canvas.width  = window.innerWidth;
    ctx.canvas.height = window.innerHeight;
  }

  let lastMouseX = 0;
  let lastMouseY = 0;
  function handleMouseMove(e) {
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    corrupt();
  }

  function arr2img(arr) {
    return window.URL.createObjectURL(new Blob([arr], { type: 'image/jpeg' }));
  }

  async function loadImage() {
    const resp = await fetch("image.jpg");
    const cont = await resp.blob();
    const buff = await cont.arrayBuffer();
    currentFile = new Uint8Array(buff);
    currentImage = new Image();
    currentImage.src = arr2img(currentFile);
  }

  function handleMouseClick() {
    if (lastWasError) return;
    if (!currentCorruptedFile) return;
    currentFile = currentCorruptedFile;
    currentImage = currentCorruptedImage;
  }

  function corrupt() {
    if (!currentFile) return;
    const touchArea = getTouchArea();
    const dataCount = currentFile.length;
    const pixelCount = touchArea[2]*touchArea[3];
    const mouseInnerX = lastMouseX - touchArea[0];
    const mouseInnerY = lastMouseY - touchArea[1];
    let mouseDataIndex = -1;
    if (mouseInnerX >= 0 && mouseInnerY >= 0 && mouseInnerX < touchArea[2] && mouseInnerY < touchArea[3]) {
     mouseDataIndex = Math.floor((mouseInnerX + mouseInnerY*touchArea[2])*(dataCount/pixelCount));
    }
    if (mouseDataIndex === -1) {
      currentCorruptedImage = currentImage;
      currentCorruptedFile = currentFile;
      return;
    }

    const corruptedTemp = new Uint8Array(new ArrayBuffer(currentFile.byteLength));
    corruptedTemp.set(new Uint8Array(currentFile));
    // beep("square", 1000 + corruptedTemp[mouseDataIndex]*4, 1, 0.1);
    corruptedTemp[mouseDataIndex] = Math.floor(Math.random()*256);



    const tempCorruptedImage = new Image();
    tempCorruptedImage.onerror = () => lastWasError = true;
    tempCorruptedImage.onload = () => {
      lastWasError = false;
      currentCorruptedImage = tempCorruptedImage;
      currentCorruptedFile = corruptedTemp;
      // currentCorruptedImage.onload = () => render(-1);
    };
    tempCorruptedImage.src = arr2img(corruptedTemp);
  }

  function getTouchArea() {
    return [ctx.canvas.width - 384, ctx.canvas.height - 256, 384, 256];
  }

  function render(delta) {
    ctx.fillStyle = "white";
    ctx.fillStyle = "#FFF1";
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    if (currentCorruptedImage) {
      //ctx.drawImage(currentCorruptedImage, 0, 0);
      ctx.drawImage(currentCorruptedImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
    } else if (currentImage) {
      ctx.drawImage(currentImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
    }
    if (currentFile) {
      const touchArea = getTouchArea();
      const dataCount = currentFile.length;
      const pixelCount = touchArea[2]*touchArea[3];
      //ctx.fillStyle = "#000";
      //ctx.fillRect(...touchArea);
      const myImageData = ctx.createImageData(touchArea[2], touchArea[3]);

      const mouseInnerX = lastMouseX - touchArea[0];
      const mouseInnerY = lastMouseY - touchArea[1];
      let mouseDataIndex = -1;
      if (mouseInnerX < touchArea[2] && mouseInnerY < touchArea[3]) {
        mouseDataIndex = Math.floor((mouseInnerX + mouseInnerY*touchArea[2])*(dataCount/pixelCount));
      }

      const data = myImageData.data;
      for (let i = 0; i < pixelCount; i++) {
        for (let j = 0; j < 3; j++) {
          const dataIndex = Math.floor((i*3+j)*(dataCount/pixelCount/3));
          data[i*4+j] = currentFile[dataIndex];
          if (mouseDataIndex == Math.floor((i)*(dataCount/pixelCount))) {
            data[i*4] = 255;
            data[i*4+1] = 0;
          }
        }
        data[i*4+3] = 255;
        
      }
      ctx.putImageData(myImageData, touchArea[0], touchArea[1]);
    }

    if (lastWasError) {
      ctx.fillStyle = "red";
      ctx.fillRect(8,8,16,16);
    }

    if (delta !== -1)
      requestAnimationFrame(render);
  }

  window.onload = () => {
    window.addEventListener('resize', resizeCanvas, false);
    window.addEventListener('mousemove', handleMouseMove, false);
    window.addEventListener('click', handleMouseClick, false);
    window.addEventListener('wheel', corrupt, false);
    resizeCanvas();
    requestAnimationFrame(render);
    loadImage();
  };
</script>
</body>
</html>
