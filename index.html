<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>touch the bytes</title>
  <style>
    @font-face {
      font-family: 'VT323';
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src: url(VT323-latin.woff2) format('woff2');
    }
    html, body {
      font-variant-ligatures: none;
      font-family: "VT323", monospace;
      font-size: 24px;
      margin: 0;
      width: 100%;
      height: 100%;
      border: 0;
      overflow: hidden;
    }
    canvas, img {
      image-rendering: pixelated;
      position: absolute;
      font-kerning: none;
    }
    #bgCanvas {
      filter: blur(24px);
    }
    #mainCanvas {
      z-index: 1;
    }
    #overlayImg {
      z-index: 2;
    }
    #menubar {
      position: absolute;
      background: #290033;
      z-index: 2;
      width: calc(100% - 48px);
      height: 64px;
      top: 24px;
      left: 24px;
    }
    #sidebarDiv {
      position: absolute;
      background: #290033;
      z-index: 2;
      padding: 12px;
      width: calc(256px - 24px);
      height: calc(100% - 72px - 64px - 24px);
      right: 24px;
      bottom: 24px;
      overflow-y: auto;
    }
    .historyEntry {
      color: #FFF;
    }
    .currentEntry {
      color: #FAA;
    }
    .historyEntry button {
      background: none;
      border: none;
      padding: 0 2px;
      font-size: inherit;
      font-family: inherit;
      color: inherit;
      text-decoration: underline;
      cursor: pointer;
    }
  </style>
</head>
<body>
<canvas id="bgCanvas"></canvas>
<canvas id="mainCanvas"></canvas>
<img id="overlayImg" draggable="false" />
<div id="menubar"></div>
<div id="sidebarDiv"></div>
<script>
  const overlayImg = document.getElementById("overlayImg");
  const sidebarDiv = document.getElementById("sidebarDiv");
  const mainCanvas = document.getElementById("mainCanvas");
  const bgCanvas = document.getElementById("bgCanvas");
  let ctx = mainCanvas.getContext("2d");
  let btx = bgCanvas.getContext("2d");
  let modificationHistory = [];
  let currentModification = null;
  let originalFile = null;
  let currentFile = null;
  let currentImage = null;
  let currentCorruptedFile = null;
  let currentCorruptedImage = null;
  let lastWasError = false;

  function resizeCanvas() {
    ctx.canvas.width  = window.innerWidth;
    ctx.canvas.height = window.innerHeight;
    btx.canvas.width  = window.innerWidth;
    btx.canvas.height = window.innerHeight;
    btx.globalAlpha = 1;
  }

  let lastMouseX = 0;
  let lastMouseY = 0;
  function handleMouseMove(e) {
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    corrupt();
  }

  function arr2img(arr) {
    return window.URL.createObjectURL(new Blob([arr], { type: 'image/jpeg' }));
  }

  document.body.ondragover = (ev) => ev.preventDefault();
  document.body.ondrop = async (ev) => {
    ev.preventDefault();
    for (const img of (ev.dataTransfer.items) ? [...ev.dataTransfer.items].filter(item => item.kind === "file").map(item => item.getAsFile()) : [...ev.dataTransfer.files]) {
      await loadImage(img);
    }
  };

  /* 
   * Fast CRC32 in JavaScript
   * 101arrowz (https://github.com/101arrowz)
   * License: MIT
   * (https://gist.github.com/101arrowz/e58695f7ccfdf74f60ba22018093edea)
   */
  const crct = new Int32Array(4096);
  for (let i = 0; i < 256; ++i) {
    let c = i, k = 9;
    while (--k) c = ((c & 1) && -306674912) ^ (c >>> 1);
    crct[i] = c;
  }
  for (let i = 0; i < 256; ++i) {
    let lv = crct[i];
    for (let j = 256; j < 4096; j += 256) lv = crct[i | j] = (lv >>> 8) ^ crct[lv & 255];
  }
  const crcts = [];
  for (let i = 0; i < 16;) crcts[i] = crct.subarray(i << 8, ++i << 8);
  const [t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16] = crcts;
  const rawCRC = (d, c) => {
    c = ~c;
    let i = 0;
    const max = d.length - 16;
    for (; i < max;)
      c = t16[d[i++] ^ (c & 255)] ^ t15[d[i++] ^ ((c >> 8) & 255)] ^ t14[d[i++] ^ ((c >> 16) & 255)] ^ t13[d[i++] ^ (c >>> 24)] ^ t12[d[i++]] ^ t11[d[i++]] ^ t10[d[i++]] ^ t9[d[i++]] ^ t8[d[i++]] ^ t7[d[i++]] ^ t6[d[i++]] ^ t5[d[i++]] ^ t4[d[i++]] ^ t3[d[i++]] ^ t2[d[i++]] ^ t1[d[i++]];
    for (; i < d.length; ++i) c = t1[(c & 255) ^ d[i]] ^ (c >>> 8);
    return ~c;
  }

  // Heal broken PNG CRCs
  let disablePNGHeal = false;
  function healPNG(arr) {
    if (disablePNGHeal) return;
    try {
      // Check PNG header
      if (arr[0] != 137) return;
      if (arr[1] != 80) return;
      if (arr[2] != 78) return;
      if (arr[3] != 71) return;

      const buff = new ArrayBuffer(4);
      const u8 = new Uint8Array(buff);
      const dv = new DataView(buff);

      let pointer = 8;
      while (pointer < arr.length) {
        u8.set(arr.slice(pointer,pointer+4));
        const chunkLen = dv.getUint32(0);
        pointer += 4;
        const crcRes = rawCRC(arr.slice(pointer,pointer+chunkLen+4));
        dv.setUint32(0, crcRes);
        pointer += chunkLen+4;
        arr.set(u8, pointer);
        pointer += 4;
      }
    } catch (e) {
      console.error(e);
    }
  }

  function editEntry(i) {
    const mod = modificationHistory[i];
    const newVal = prompt("Enter new value as hex (00-ff):", mod[1].toString(16).padStart(2, '0'));
    if (!newVal) return;
    const parsedVal = parseInt(newVal.substring(Math.max(0,newVal.length-2)), 16);
    if (isNaN(parsedVal)) return;
    mod[1] = parsedVal;
    applyModifications();
  }
  function visEntry(i) {
    modificationHistory[i][2] = !modificationHistory[i][2];
    applyModifications();
  }
  function delEntry(i) {
    modificationHistory.splice(i, 1);
    applyModifications();
  }

  async function loadImage(img, modHistory) {
    const buff = await img.arrayBuffer();
    originalFile = new Uint8Array(buff);
    currentFile = new Uint8Array(buff);
    currentImage = new Image();
    currentImage.src = arr2img(currentFile);
    currentCorruptedImage = currentImage;
    currentCorruptedFile = currentFile;
    overlayImg.src = currentCorruptedImage.src;

    modificationHistory = modHistory ?? [];
    currentModification = null;
    updateDom();
  }

  function applyModifications() {
    const corruptedTemp = new Uint8Array(new ArrayBuffer(originalFile.byteLength));
    corruptedTemp.set(new Uint8Array(originalFile));
    for (const modification of modificationHistory ) {
      if (!modification[2])
        corruptedTemp[modification[0]] = modification[1];
    }
    healPNG(corruptedTemp);
    currentCorruptedFile = corruptedTemp;
    currentCorruptedImage.src = arr2img(corruptedTemp);
    currentFile = currentCorruptedFile;
    currentImage = currentCorruptedImage;
    overlayImg.src = currentCorruptedImage.src;
    updateDom();
  }

  function handleMouseClick() {
    mouseDataIndex = getMouseDataIndex();
    if (mouseDataIndex >= 0 && !lastWasError && currentCorruptedFile && currentModification) {
      modificationHistory.push(currentModification);
      currentModification = null;
      //currentFile = currentCorruptedFile;
      //currentImage = currentCorruptedImage;
      //overlayImg.src = currentCorruptedImage.src;
      applyModifications();
    }
  }

  function getMouseDataIndex() {
    const touchArea = getTouchArea();
    const dataCount = currentFile.length;
    const pixelCount = touchArea[2]*touchArea[3];
    const mouseInnerX = lastMouseX - touchArea[0];
    const mouseInnerY = lastMouseY - touchArea[1];
    const yReduce = Math.floor(Math.sqrt(pixelCount/dataCount)) || 1;
    let mouseDataIndex = -1;
    if (mouseInnerX >= 0 && mouseInnerY >= 0 && mouseInnerX < touchArea[2] && mouseInnerY < touchArea[3]) {
     mouseDataIndex = Math.floor((mouseInnerX + Math.floor(mouseInnerY/yReduce)*touchArea[2])*(dataCount/pixelCount)*yReduce);
    }
    return mouseDataIndex;
  }


  function corrupt() {
    if (!currentFile) return;
    mouseDataIndex = getMouseDataIndex();
    if (mouseDataIndex === -1) {
      if (currentModification) {
        currentModification = null;
        document.querySelector(".currentEntry").innerText = mod2txt(currentModification);
        currentCorruptedImage = currentImage;
        currentCorruptedFile = currentFile;
        overlayImg.src = currentCorruptedImage.src;
      }
      return;
    }

    const corruptedTemp = new Uint8Array(new ArrayBuffer(currentFile.byteLength));
    corruptedTemp.set(new Uint8Array(currentFile));
    // beep("square", 1000 + corruptedTemp[mouseDataIndex]*4, 1, 0.1);
    const randByte = Math.floor(Math.random()*256);
    corruptedTemp[mouseDataIndex] = randByte;
    currentModification = [mouseDataIndex, randByte, false];
    document.querySelector(".currentEntry").innerText = mod2txt(currentModification);
    healPNG(corruptedTemp);

    const tempCorruptedImage = new Image();
    tempCorruptedImage.onerror = () => lastWasError = true;
    tempCorruptedImage.onload = () => {
      lastWasError = false;
      if (currentModification == null) return;
      currentCorruptedImage = tempCorruptedImage;
      currentCorruptedFile = corruptedTemp;
      overlayImg.src = currentCorruptedImage.src;
      // currentCorruptedImage.onload = () => render(-1);
    };
    tempCorruptedImage.src = arr2img(corruptedTemp);
  }

  function getTouchArea() {
    //return [ctx.canvas.width - 384, ctx.canvas.height - 256, 384, 256];
    return getLayout().glitchbox;
  }

  let imageRatio = 1;
  function getLayout(barsOnly) {
    const p = 24; // padding
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    const menubar = [p, p, w-p*2, 64];
    const sidebar = [w-256-p, p*2+menubar[3], 256, h-p*3-menubar[3]];
    if (barsOnly) return { menubar, sidebar };
    const mainHeight = h - menubar[3] - p*3;
    const mainWidth = w - sidebar[2] - p*3;
    const maxImgWidth = Math.floor((mainWidth-p)*0.75);
    if (currentImage) {
      imageRatio = currentImage.naturalWidth/currentImage.naturalHeight || imageRatio;
    }
    const imagebox = [p, 2*p+menubar[3], Math.floor(imageRatio*mainHeight), mainHeight];
    if (imagebox[2] > maxImgWidth) {
      imagebox[2] = maxImgWidth;
      imagebox[3] = Math.floor(maxImgWidth/imageRatio);
      imagebox[1] += Math.floor((mainHeight - imagebox[3])/2);
    }
    const glitchbox = [p*2 + imagebox[2], 2*p+menubar[3], Math.max(1, mainWidth - imagebox[2] - p), Math.max(1, mainHeight)];
    return {
      menubar,
      sidebar,
      imagebox,
      glitchbox,
    };
  }

  function mod2txt(mod) {
    if (!mod) return "";
    return `${mod[0].toString(16).padStart(6, '0')} > ${mod[1].toString(16).padStart(2, '0')}`.replace(/f/g, "f\u200b");
  }

  function updateDom() {
    // const layout = getLayout(true);
    // sidebarDiv.style.left = `${layout.sidebar[0]}px`;
    // sidebarDiv.style.top = `${layout.sidebar[1]}px`;
    // sidebarDiv.style.width = `${layout.sidebar[2]}px`;
    // sidebarDiv.style.height = `${layout.sidebar[3]}px`;

    sidebarDiv.innerText = "";

    let i = 0;
    for (const modification of [...modificationHistory, currentModification] ) {
      const entry = document.createElement("div");
      const isCurrent = modification === currentModification;
      entry.innerText = mod2txt(modification);
      entry.classList.add("historyEntry");
      if (isCurrent) entry.classList.add("currentEntry");
      if (!isCurrent) {
        const entryIndex = i;
        const buttons = document.createElement("span");
        const editBtn = document.createElement("button");
        const visBtn = document.createElement("button");
        const delBtn = document.createElement("button");
        editBtn.innerText = "edit";
        editBtn.onclick = () => editEntry(entryIndex);
        visBtn.innerText = modification[2] ? "show" : "hide";
        visBtn.onclick = () => visEntry(entryIndex);
        delBtn.innerText = "x";
        delBtn.onclick = () => delEntry(entryIndex);
        [editBtn, visBtn, delBtn].forEach(b => buttons.appendChild(b));
        buttons.style.float = "right";
        entry.appendChild(buttons);
      }
      sidebarDiv.appendChild(entry);
      i++;
    }
  }

  function render(delta) {
    try {
    const layout = getLayout();

    ctx.fillStyle = "white";
    ctx.fillStyle = "#FFF1";
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    if (currentCorruptedImage) {
      //ctx.drawImage(currentCorruptedImage, 0, 0);
      //ctx.drawImage(currentCorruptedImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
      btx.drawImage(currentCorruptedImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
      btx.globalAlpha = 0.02;
      //ctx.drawImage(currentCorruptedImage, ...layout.imagebox);
      overlayImg.style.left = `${layout.imagebox[0]}px`;
      overlayImg.style.top = `${layout.imagebox[1]}px`;
      overlayImg.style.width = `${layout.imagebox[2]}px`;
      overlayImg.style.height = `${layout.imagebox[3]}px`;
    } else if (currentImage) {
      ctx.drawImage(currentImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
    }
    if (currentFile) {
      const touchArea = getTouchArea();
      const dataCount = currentFile.length;
      const pixelCount = touchArea[2]*touchArea[3];
      const yReduce = Math.floor(Math.sqrt(pixelCount/dataCount)) || 1;
      //ctx.fillStyle = "#000";
      //ctx.fillRect(...touchArea);
      const myImageData = ctx.createImageData(touchArea[2], touchArea[3]);
      const mouseDataIndex = getMouseDataIndex();

      const data = myImageData.data;
      for (let i = 0; i < pixelCount/yReduce; i++) {
        for (let yr = 0; yr < yReduce; yr++) {
          const pix = ((Math.floor(i/touchArea[2])*yReduce+yr)*touchArea[2] + (i%touchArea[2]))*4;
          for (let j = 0; j < 3; j++) {
            const dataIndex = Math.floor((i*yReduce*3+j)*(dataCount/pixelCount/3));
            data[pix+j] = currentFile[dataIndex];
            if (mouseDataIndex == Math.floor((i*yReduce)*(dataCount/pixelCount))) {
              data[pix] = 255;
              data[pix+1] = 0;
            }
          }
          data[pix+3] = 255;
        }
        
      }
      ctx.putImageData(myImageData, touchArea[0], touchArea[1]);
    }

    if (lastWasError) {
      ctx.fillStyle = "red";
      ctx.fillRect(8,8,16,16);
    }
    } catch (e) {
      console.error(e);
    }

    if (delta !== -1)
      requestAnimationFrame(render);
  }

  window.onload = () => {
    window.addEventListener('resize', resizeCanvas, false);
    window.addEventListener('mousemove', handleMouseMove, false);
    window.addEventListener('click', handleMouseClick, false);
    window.addEventListener('wheel', corrupt, false);
    resizeCanvas();
    updateDom();
    requestAnimationFrame(render);
    
    (async () => {
      const resp = await fetch("image.jpg");
      const cont = await resp.blob();
      loadImage(cont);
    })()
  };
</script>
</body>
</html>
